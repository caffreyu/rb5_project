#!/usr/bin/env python

from map_constants import *
import numpy as np
import matplotlib.pyplot as plt
from a_star import aStar
from voronoi import voronoi
import sys
from copy import deepcopy
import pickle as pk
from math import ceil

# Add verbose=true or true to the command line to see the plots and waypoints
cmd = sys.argv
verbose = False
if len(cmd) > 1: 
    if 'true' in cmd[1] or 'True' in cmd[1]:
        verbose = True

# Get height, width of the map
height, width = 0, 0
for _, value in dict_outside_lm.items():
    x, y = value
    width = max(width, x)
    height = max(height, y)
arr_h, arr_w = int(height / cell_size) + 1, int(width / cell_size) + 1

# Build the initial map
map = np.zeros((arr_h, arr_w))

def ground_position_transform(ground_pos):
    '''Transform from ground position to map position.'''
    x, y = ground_pos
    return (height - y, x)

def array_position_transform(map_pos):
    '''Transform from map position to array position/index.'''
    x, y = map_pos
    row, col = int(x / cell_size), int(y / cell_size)
    return (row, col)

def ground_to_array_transform(ground_pos):
    '''Transform from ground position to array index.'''
    return array_position_transform(
        ground_position_transform(
            ground_pos
        )
    )

def array_to_ground_transform(arr_pos):
    '''Transform array index to ground position.'''
    x, y = arr_pos
    # Kinda cheat here because I used 3 - x * cell_size instead of height
    return [y * cell_size, 3 - x * cell_size]

# Process obstacles
obs_lm1 = ground_to_array_transform(dict_inside_lm['lm1'])
obs_lm2 = ground_to_array_transform(dict_inside_lm['lm2'])
obs_lm3 = ground_to_array_transform(dict_inside_lm['lm3'])
obs_lm4 = ground_to_array_transform(dict_inside_lm['lm4'])
min_x = min(obs_lm1[0], obs_lm2[0], obs_lm3[0], obs_lm4[0])
min_y = min(obs_lm1[1], obs_lm2[1], obs_lm3[1], obs_lm4[1])
max_x = max(obs_lm1[0], obs_lm2[0], obs_lm3[0], obs_lm4[0])
max_y = max(obs_lm1[1], obs_lm2[1], obs_lm3[1], obs_lm4[1])

def can_add_obs(arr_pos):
    '''Checking if arr_pos can be treated as an obstacle.'''
    x, y = arr_pos
    return 0 <= x < arr_h and 0 <= y < arr_w

def add_obs(min_x, min_y, max_x, max_y):
    '''Add obstacle area to the mapping array.'''
    clearance = ceil(robot_clearance / cell_size)
    # clearance = 0
    for x in range(min_x - 1 - clearance, max_x + 2 + clearance):
        for y in range(min_y - 1 - clearance, max_y + 2 + clearance):
            if can_add_obs(arr_pos = (x, y)):
                map[x, y] = 1

add_obs(min_x, min_y, max_x, max_y)

# Add walls
for i in range(ceil(robot_clearance / cell_size)):
    map[:, i] = map[:, -1 - i] = map[i, :] = map[-1 - i, :] = 1

# Show the map
if verbose:
    plt.imshow(map)
    plt.show()

def generate_waypoints(path):
    '''Generate waypoints file from generated path.'''
    arr_track = list(arr_start)
    prev_action = path.pop(0)
    arr_track[0] += prev_action[0]
    arr_track[1] += prev_action[1]
    waypoints = []

    while path:
        curr_action = path.pop(0)
        delta_x, delta_y = curr_action
        x, y = arr_track
        if curr_action != prev_action:
            waypoints.append(array_to_ground_transform([x, y]))
        arr_track = [x + delta_x, y + delta_y]
        prev_action = curr_action

    waypoints.append(array_to_ground_transform(arr_goal))
    return waypoints

if __name__ == '__main__':
    # Test A* path planner
    arr_start = ground_to_array_transform(start)
    arr_goal = ground_to_array_transform(goal)
    a_star = aStar(
        start = arr_start,
        goal = arr_goal,
        tolerance = tolerance,
        map = map,
    )

    a_star.plan_path()

    # Show the path
    if verbose:
        map_disp = deepcopy(map)
        disp_start = deepcopy(arr_start)
        map_disp[arr_start[0], arr_start[1]] = 3
        for x, y in a_star.path:
            x_prev, y_prev = disp_start
            disp_start = [x_prev + x, y_prev + y]
            map_disp[x_prev + x, y_prev + y] = 2
        map_disp[arr_goal[0], arr_goal[1]] = 4

        plt.imshow(map_disp)
        plt.title('Path Generated by A* Path Planning Algorithm')
        plt.show()

    # Generate waypoints
    arr_path = a_star.path
    aStar_waypoints = generate_waypoints(deepcopy(arr_path))

    if verbose:
        print ('[INFO] Printing waypoints generated by A*')
        print (np.array(aStar_waypoints))

    # Store waypoints in a pickle file
    with open('a_star_waypoints.pickle', 'wb') as f:
        pk.dump(np.array(aStar_waypoints), f)
    
    # Test the Voronoi path planner
    voro = voronoi(map, arr_start, arr_goal, tolerance, verbose)
    voro_path = voro.plan_path()
    voro_waypoitns = generate_waypoints(deepcopy(voro_path))

    if verbose:
        map_disp = deepcopy(map)
        disp_start = deepcopy(arr_start)
        map_disp[arr_start[0], arr_start[1]] = 3
        for x, y in voro_path:
            x_prev, y_prev = disp_start
            disp_start = [x_prev + x, y_prev + y]
            map_disp[x_prev + x, y_prev + y] = 2
        map_disp[arr_goal[0], arr_goal[1]] = 4

        plt.imshow(map_disp)
        plt.title('Path Generated by Voronoi Path Planning Algorithm')
        plt.show()

        print ('[INFO] Printing waypoints generated by A*')
        print (np.array(voro_waypoitns))

        with open('voronoi_waypoints.pickle', 'wb') as f:
            pk.dump(np.array(voro_waypoitns), f)
